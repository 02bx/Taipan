namespace ES.Taipan.Inspector.AddOns.WebApplicationVulnerability

open System
open System.Threading
open System.Collections.Generic
open System.Collections.Concurrent
open System.Text.RegularExpressions
open ES.Taipan.Inspector
open ES.Taipan.Inspector.AddOns
open ES.Taipan.Infrastructure.Service
open ES.Taipan.Infrastructure.Messaging
open ES.Taipan.Infrastructure.Network
open ES.Taipan.Fingerprinter
open ES.Fslog

type ApplicationVulnerabilityDescriptor = {
    Id : Guid
    Application : String
    AffectedVersions: String list
    VulnerabilityName: String
    ExternalReferer: String
    Impact : String
    Note: String
}

type WebApplicationVulnerabilityAddOn() as this =
    inherit BaseStatelessAddOn("Vulnerable Web Application AddOn", "864BA3EF-E9E2-4B18-AE7F-4530CEBCCBF6", 1)
    let _signaledPath = new HashSet<String>()
        
    let reportSecurityIssue(uri: Uri, appVulnDescription: ApplicationVulnerabilityDescriptor, installedVersion: Version) =        
        let securityIssue = 
            new SecurityIssue(
                this.Id, 
                Name = "Vulnerable Web Application", 
                Uri = uri, 
                EntryPoint = EntryPoint.UriSegment,
                Note = appVulnDescription.VulnerabilityName
            )

        // add properties for the description of the vulnerability
        [
            ("Id", appVulnDescription.Id.ToString())
            ("Application", appVulnDescription.Application)
            ("AffectedVersions", String.Join(",", appVulnDescription.AffectedVersions))
            ("VulnerabilityName", appVulnDescription.VulnerabilityName)
            ("Impact", appVulnDescription.Impact)
            ("InstalledVersion", installedVersion.ToString())
            ("ExternalReferer", appVulnDescription.ExternalReferer)
        ] |> List.iter(fun (name, value) -> securityIssue.Details.Properties.Add(name, value))

        this.Context.Value.AddSecurityIssue(securityIssue)

    let cleanVersion(version: String) =
        Regex.Replace(version, "[^0-9.]", String.Empty)

    let isStandardVersionFormat(version: String) =
        let v = ref(new Version())
        Version.TryParse(version, v)

    let formatVersion(versions: String seq) =
        versions
        |> Seq.map cleanVersion
        |> Seq.filter isStandardVersionFormat
        |> Seq.map Version.Parse
            
    let parseAffectedVersionsToPredicate(vulnerableVersionStrRaw: String) =
        // the vulnerable version are described with an optional comparison sign. In this way is possible to
        // specify all version prior to a given one, like: <1.2.3.4, or <=1.2.3.4 or simply 1.2.3.4. 
        // It is also possible to specify an inclusive range, like 1.2.0-1.2.8
        let vulnerableVersionStr = vulnerableVersionStrRaw.Trim()
        let m = Regex.Match(vulnerableVersionStr, "(.+)-(.+)", RegexOptions.IgnorePatternWhitespace)
        if m.Success then
            // it is a range comparison
            let minorVersion = Version.Parse(m.Groups.[1].Value)
            let majorVersion = Version.Parse(m.Groups.[2].Value)
            fun (version: Version) -> version >= minorVersion && version <= majorVersion

        elif vulnerableVersionStr.StartsWith("<") || vulnerableVersionStr.StartsWith(">") then
            // it is a minor or greater comparison
            let comparisonFunc =
                if vulnerableVersionStr.StartsWith("<=") then (<=)
                elif vulnerableVersionStr.StartsWith("<") then (<)
                elif vulnerableVersionStr.StartsWith(">") then (>)
                elif vulnerableVersionStr.StartsWith(">=") then (>=)
                else failwith "Ivalid vulnerable version string"

            let effectiveVulnerableVersion = Version.Parse(Regex.Replace(vulnerableVersionStr, "^[^0-9.]+", String.Empty))
            fun (version: Version) -> comparisonFunc version effectiveVulnerableVersion             

        else
            // it is an exact match
            let comparisonVersion = Version.Parse(vulnerableVersionStr)
            fun (version: Version) -> version = comparisonVersion

    let isVersionAffected (uri: Uri) (webApplication: WebApplicationIdentified) (vulnerability: ApplicationVulnerabilityDescriptor) (version: Version) =
        vulnerability.AffectedVersions
        |> List.exists(fun vulnerableVersionStr ->
            let isVulnerablePredicate = parseAffectedVersionsToPredicate vulnerableVersionStr
            isVulnerablePredicate version
        )

    let checkForVulnerabilityInApplication(webApplication: WebApplicationIdentified) =
        let filter = fun  vulnDesc -> vulnDesc.Application.Equals(webApplication.WebApplicationFingerprint.Name, StringComparison.OrdinalIgnoreCase)
        this.Context.Value.AddOnStorage.GetProperties<ApplicationVulnerabilityDescriptor>(filter)
        |> Seq.iter(fun vulnDesc ->
            webApplication.IdentifiedVersions            
            |> Seq.map(fun kv -> kv.Key.Version)
            |> formatVersion
            |> Seq.toList
            |> List.filter(isVersionAffected webApplication.Request.Request.Uri webApplication vulnDesc)
            |> List.tryHead            
            |> (function
                | Some affectedVersion -> reportSecurityIssue(webApplication.Request.Request.Uri, vulnDesc, affectedVersion)
                | None -> ()
            )
        )
                                                
    default this.Scan(testRequest: TestRequest, stateController: ServiceStateController) =
        if testRequest.RequestType = TestRequestType.WebApplicationIdentified && _signaledPath.Add(testRequest.WebRequest.HttpRequest.Uri.AbsolutePath) then
            checkForVulnerabilityInApplication(testRequest.GetData<WebApplicationIdentified>())