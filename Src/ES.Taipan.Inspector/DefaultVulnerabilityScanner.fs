namespace ES.Taipan.Inspector

open System
open System.Text.RegularExpressions
open System.Threading
open System.Threading.Tasks
open System.Linq
open System.Collections.Concurrent
open System.Collections.Generic
open ES.Taipan.Infrastructure.Threading
open ES.Taipan.Infrastructure.Network
open ES.Taipan.Infrastructure.Service
open ES.Taipan.Infrastructure.Messaging
open ES.Taipan.Infrastructure.Validation
open ES.Fslog

type VulnerabilityScannerMetrics(requestsToProcess: _ seq, requestsToReProcess: _ seq) =
    inherit ServiceMetrics("Vulnerability Scanner")
    let mutable _numRequestProcessed = 0
    
    member this.CurrentState(status: String) =
        this.AddMetric("Current status", status)     

    member this.RequestPerSeconds(numReq: Int32) =
        this.AddMetric("Request processed per seconds", numReq.ToString())

    member this.CurrentTestedRequest(req: String) =
        this.AddMetric("Last tested request", req)

    member this.LastActivatedAddOn(addOnName: String) =
        this.AddMetric("Last activated addOn", addOnName)

    member this.LastCompletedAddOn(addOnName: String) =
        this.AddMetric("Last completed addOn", addOnName)

    member this.InitializationCompleted() =
        this.AddMetric("Initialization completed", "true")

    member this.RequestProcessed() =
        _numRequestProcessed <- _numRequestProcessed + 1
        this.PercentageCompletation()

    member this.PercentageCompletation() =
        let total = requestsToProcess.Count() + requestsToReProcess.Count()
        let percentage = float _numRequestProcessed / float total
        this.AddMetric("Completation", percentage.ToString())

type DefaultVulnerabilityScanner(settings: VulnerabilityScannerSettings, addOnManager: IVulnerabilityScannerAddOnManager, messageBroker: IMessageBroker, logProvider: ILogProvider) as this = 
    let mutable _processCompletedInvoked = false
    let mutable _stopRequested = false
    let _processCompleted = new Event<IService>()
    let _initializationCompleted = new Event<IService>()
    let _stateController = new ServiceStateController()
    let _taskManager = new TaskManager(_stateController, true, false, ConcurrentLimit = 20)  
    let _requestsToProcess = new BlockingCollection<TestRequest>()
    let _requestsToReProcess = new ConcurrentBag<TestRequest>()
    let _noMoreTestRequestsToProcess = new Event<IVulnerabilityScanner>()    
    let _serviceDiagnostics = new ServiceDiagnostics()
    let _serviceMetrics = new VulnerabilityScannerMetrics(_requestsToProcess, _requestsToProcess)
    let _statusMonitor = new Object()
    let _runToCompletationCalledLock = new ManualResetEventSlim()
    let _activatedAddOns = new List<IVulnerabilityScannerAddOn>()

    let _logger =
        log "DefaultVulnerabilityScanner"
        |> info "VulnerabilityScannerPaused" "Vulnerability scanner Paused"
        |> info "VulnerabilityScannerStopped" "Vulnerability scanner Stopped"
        |> info "VulnerabilityScannerResumed" "Vulnerability scanner Resumed"
        |> info "AddOnInitialized" "Activated addOn: {0}"
        |> info "FoundIssue" "Security Issue: {0}"
        |> verbose "StopRequested" "Stop requested"
        |> verbose "WaitRunToCompletation" "Stop requested and wait for RunToCompletation message"
        |> verbose "RunToCompletation" "RunToCompletation message received"
        |> verbose "GoIdle" "Go in Idle state"
        |> buildAndAdd logProvider

    let handleControlMessage(sender: Object, message: Envelope<String>) =
        match message.Item.ToUpper() with
        | "STOP" -> this.Stop()
        | "PAUSE" -> this.Pause()
        | "RESUME" -> this.Resume()
        | _ -> ()

    let triggerIdleState() =
        _serviceMetrics.CurrentState("Idle")
        _serviceDiagnostics.GoIdle()
        _logger?GoIdle()
        _noMoreTestRequestsToProcess.Trigger(this)

    let checkVulnerabilityScannerState() =
        if _requestsToProcess |> Seq.isEmpty then
            triggerIdleState()

    let completeAllAddOns() =
        addOnManager.GetAddOns()
        |> Seq.iter(fun addOn -> addOn.RunToCompletation(_stateController))

    let completeProcess() =
        if not _processCompletedInvoked then
            _processCompletedInvoked <- true
            _stateController.ReleaseStopIfNecessary()
            _stateController.UnlockPause()
            completeAllAddOns()
            _processCompleted.Trigger(this)
            _serviceMetrics.CurrentState("Completed")

    let isBlackListed(testRequest: TestRequest) =
        let path = testRequest.WebRequest.HttpRequest.Uri.AbsolutePath
        settings.BlacklistedPattern
        |> Seq.exists(fun pattern -> Regex.IsMatch(path, pattern, RegexOptions.IgnoreCase))

    let processTestRequest(testRequest: TestRequest) =
        if not _stateController.IsStopped && not _stopRequested && not(isBlackListed(testRequest)) then            
            _serviceMetrics.CurrentTestedRequest(testRequest.WebRequest.HttpRequest.Uri.ToString())
            this.Scan(testRequest)

    let processReCrawlingRequest() =
        _serviceMetrics.CurrentState("Running")
        _serviceDiagnostics.Activate()
        _requestsToReProcess
        |> Seq.iter(fun testRequest ->
            if not _stateController.IsStopped && not _stopRequested then                
                processTestRequest(testRequest)
        )
        _serviceMetrics.CurrentState("Idle")
        _serviceDiagnostics.GoIdle()
        
    let vulnerabilityScannerLoop() =
        async {
            try
                // code to get request done per second metric
                let numOfServicedRequests = ref 0
                let timer = new System.Timers.Timer(1000.)                
                timer.Elapsed.Add(fun _ -> 
                    let oldVal = Interlocked.Exchange(numOfServicedRequests, 0)
                    _serviceMetrics.RequestPerSeconds(oldVal)
                )                
                timer.Start()

                // main loop
                _initializationCompleted.Trigger(this)
                _serviceMetrics.InitializationCompleted()
                for testRequest in _requestsToProcess.GetConsumingEnumerable() do
                    if not _stateController.IsStopped && not _stopRequested then
                        lock _statusMonitor (fun () ->
                            _serviceDiagnostics.Activate()
                            _serviceMetrics.CurrentState("Running")
                            processTestRequest(testRequest)
                            _serviceMetrics.RequestProcessed()
                            Interlocked.Increment(numOfServicedRequests) |> ignore
                            checkVulnerabilityScannerState()
                        )    
                        
                if _stopRequested then
                    // wait until the run to completation is called
                    checkVulnerabilityScannerState()
                    _stateController.ReleaseStopIfNecessary()
                    _logger?WaitRunToCompletation()
                    _runToCompletationCalledLock.Wait()                 

                // no more fingerprint requests to process
                completeProcess()
            with
            | :? OperationCanceledException ->            
                _stateController.ReleaseStopIfNecessary() 
                triggerIdleState()
            
        } |> Async.Start

    let handleTestRequestMessage(sender: Object, testRequest: Envelope<TestRequest>) = 
        if not _stateController.IsStopped && not _stopRequested && not _requestsToProcess.IsAddingCompleted then
            if testRequest.Item.RequestType = TestRequestType.ReCrawledPage then
                _requestsToReProcess.Add(testRequest.Item)  
            else
                _requestsToProcess.Add(testRequest.Item)

    let handleInspectorSettingsMessageMessage(sender: Object, message: Envelope<InspectorSettingsMessage>) =
        message.Item.Settings <- Some settings

    let activateAddOn (addOn: IVulnerabilityScannerAddOn) = 
        let isWrapperAddOn = addOn.Id = Guid.Empty
        settings.ActivateAllAddOns || settings.AddOnIdsToActivate.Contains(addOn.Id) || isWrapperAddOn

    let reportSecurityIssue(securityIssue: SecurityIssue) =
        let message = new NewSecurityIssueFoundMessage(securityIssue)
        _logger?FoundIssue(securityIssue.ToString())
        messageBroker.Dispatch(this, message)
        
    do
        // message subscription
        messageBroker.Subscribe<String>(handleControlMessage)
        messageBroker.Subscribe<TestRequest>(handleTestRequestMessage)
        messageBroker.Subscribe<InspectorSettingsMessage>(handleInspectorSettingsMessageMessage)
        messageBroker.Subscribe<RequestMetricsMessage>(fun (sender, msg) -> msg.Item.AddResult(this, _serviceMetrics))
        
        // load only enabled addOn
        addOnManager.LoadAddOns()
        addOnManager.GetAddOns()
        |> List.filter activateAddOn
        |> List.iter(fun addOn -> 
            let fileSystemAddOnStorage = new FilesystemAddOnStorage(addOn)
            let context = new Context(fileSystemAddOnStorage, reportSecurityIssue)

            let message = new NewWebPageRequestorMessage()
            messageBroker.Dispatch(this, message)
            if addOn.Initialize(context, message.WebPageRequestor.Value, messageBroker, logProvider) then
                _activatedAddOns.Add(addOn)
                _logger?AddOnInitialized(addOn.Name)
        )

    static member VulnerabilityScannerId = Guid.Parse("3E61BB90-9B40-4732-83AA-7AF28C43DB8B")
    member val ServiceId = DefaultVulnerabilityScanner.VulnerabilityScannerId with get
    member this.ProcessCompleted = _processCompleted.Publish
    member this.InitializationCompleted = _initializationCompleted.Publish
    member this.NoMoreTestRequestsToProcess = _noMoreTestRequestsToProcess.Publish
    member val Diagnostics = _serviceDiagnostics with get

    member this.Scan(testRequest: TestRequest) =
        let addOns = _activatedAddOns |> Seq.toList

        // run in parallels all the addOns according to their priority
        if addOns.Any() then
            let maxPriority = (addOns |> List.maxBy(fun addOn -> addOn.Priority)).Priority
            for currentPriority in maxPriority .. -1 .. 0 do
                let tasks = new List<Task>()
                for addOn in addOns |> List.filter(fun addOn -> addOn.Priority = currentPriority) do                    
                    if not _stateController.IsStopped && not _stopRequested then
                        _serviceMetrics.LastActivatedAddOn(addOn.Name)

                        _taskManager.RunTask(fun serviceStateController -> 
                            if not _stopRequested then
                                addOn.Scan(testRequest, serviceStateController)
                                _serviceMetrics.LastCompletedAddOn(addOn.Name)

                            // release lock when completed
                            serviceStateController.ReleaseStopIfNecessary()
                            serviceStateController.UnlockPause()
                        , not addOn.IsBackgroundService) |> tasks.Add
                Task.WaitAll(tasks |> Seq.toArray)

    member this.Pause() = 
        // if there aren't requests that must be processed the not blocking call of Pause must be executed because the
        // main loop is waiting for requests and until this requirement old the WaitInInPauseState method
        // isn't called, so a deadlock may occour.
        let action =
            if Monitor.TryEnter(_statusMonitor) && _serviceDiagnostics.IsIdle then _stateController.NotBlockingPause
            else _stateController.Pause

        if action() then
            _logger?VulnerabilityScannerPaused()
            _serviceMetrics.CurrentState("Paused")
                
    member this.Resume() = 
        if _stateController.ReleasePause() then
            _logger?VulnerabilityScannerResumed()
            _serviceMetrics.CurrentState("Running")
            checkVulnerabilityScannerState()
        
    member this.Stop() =  
        _logger?StopRequested()
        _stopRequested <- true          
        _requestsToProcess.CompleteAdding()  

        if _stateController.Stop() then
            _logger?VulnerabilityScannerStopped()    
            _serviceMetrics.CurrentState("Stopped")        

    member this.RunToCompletation() =
        _serviceMetrics.CurrentState("Run to completation")
        _logger?RunToCompletation()

        // process re-crawling request. This is done after because if I process the re-crawling request
        // as normal test request there can be race condition.
        processReCrawlingRequest()

        // must verify that all the plugins completed their work before to invoke the completeProcess method
        _requestsToProcess.CompleteAdding()    

        // unlock if locked by stop request
        _runToCompletationCalledLock.Set()

    member this.Activate() =
        // run the main loop
        vulnerabilityScannerLoop()

    interface IDisposable with
        member this.Dispose() =
            // dispose all addons
            for addOn in addOnManager.GetAddOns() do
                if addOn :? IDisposable then
                    let disposable = addOn :?> IDisposable
                    disposable.Dispose()            
        
    interface IVulnerabilityScanner with
        member this.ServiceId
            with get() = this.ServiceId

        member this.Diagnostics
            with get() = this.Diagnostics

        member this.Pause() = 
            this.Pause()

        member this.Resume() = 
            this.Resume()
        
        member this.Stop() =    
            this.Stop()

        member this.RunToCompletation() =
            this.RunToCompletation()

        member this.Activate() =
            this.Activate()

        member this.Scan(testRequest: TestRequest) =
            this.Scan(testRequest)
            
        member this.ProcessCompleted
            with get() = this.ProcessCompleted

        member this.InitializationCompleted
            with get() = this.InitializationCompleted

        member this.NoMoreTestRequestsToProcess
            with get() = this.NoMoreTestRequestsToProcess